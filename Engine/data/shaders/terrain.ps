Texture2D shaderTexture1 : register(t0);
Texture2D normalTexture1 : register(t1);
Texture2D shaderTexture2 : register(t2);
Texture2D normalTexture2 : register(t3);
Texture2D shaderTexture3 : register(t4);
Texture2D normalTexture3 : register(t5);
Texture2D shaderTexture4 : register(t6);
Texture2D normalTexture4 : register(t7);
Texture2D alphaTexture1 : register(t8);
SamplerState SampleType;

cbuffer LightBuffer
{
    float4 ambientColor;
    float4 diffuseColor;
    float3 lightDirection;
    float lightIntensity;
    float lightDetailIntensity;
    float distanceIntensity;
    float countLayers;
    float padding;
};


struct PixelInputType
{
    float4 position : SV_POSITION;
    float4 tex : TEXCOORD0;
    float3 normal : NORMAL;
    float3 tangent : TANGENT;
    float3 binormal : BINORMAL;
    float4 depthPosition : TEXCOORD1;
    float2 tex2 : TEXCOORD2;
};

float4 TerrainPixelShader(PixelInputType input) : SV_TARGET
{
    float depthValue;
    float detailBrightness;
    float4 detailColor;
    float4 bumpMap;
    float3 bumpNormal;
    float lightIntensity1;
    float lightIntensity2;
    float lightIntensity3;
    float lightIntensity4;
    float4 textureColor1;
    float4 textureColor2;
    float4 textureColor3;
    float4 textureColor4;
    float3 lightDir;
    float4 alphaMap1;
    float4 color;

    // Invert the light direction for calculations.
    lightDir = -lightDirection;

    // Get the depth value of the pixel by dividing the Z pixel depth by the homogeneous W coordinate.
    depthValue = input.depthPosition.z / input.depthPosition.w;

    bumpNormal = input.normal;
    lightIntensity1 = saturate(dot(bumpNormal, lightDir));
    lightIntensity2 = lightIntensity1;
    lightIntensity3 = lightIntensity1;
    lightIntensity4 = lightIntensity1;

    // Check if the depth value is close to the screen, if so we will apply the detail texture.
    if (depthValue < distanceIntensity) {
        /*if (isDetailTexture) {
            detailColor = detailTexture.Sample(SampleType, input.tex.zw);
            detailBrightness = lightDetailIntensity;
            textureColor = textureColor * detailColor * detailBrightness;
        }*/

        bumpMap = normalTexture1.Sample(SampleType, input.tex);
        bumpMap = (bumpMap * 2.0f) - 1.0f;
        bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
        bumpNormal = normalize(bumpNormal);
        lightIntensity1 = saturate(dot(bumpNormal, lightDir));
    }	

    textureColor1 = shaderTexture1.Sample(SampleType, input.tex);
    color = saturate(ambientColor + (diffuseColor * lightIntensity * lightIntensity1 * textureColor1));

    if (countLayers > 2) {
        if (countLayers == 8) {
            alphaMap1 = alphaTexture1.Sample(SampleType, input.tex2);
        } else if (countLayers == 6) {
            alphaMap1 = shaderTexture4.Sample(SampleType, input.tex2);
        } else {
            alphaMap1 = shaderTexture3.Sample(SampleType, input.tex2);
        }

		if (depthValue < distanceIntensity) {
            bumpMap = normalTexture2.Sample(SampleType, input.tex);
            bumpMap = (bumpMap * 2.0f) - 1.0f;
            bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
            bumpNormal = normalize(bumpNormal);
            lightIntensity2 = saturate(dot(bumpNormal, lightDir));
		}

        textureColor2 = shaderTexture2.Sample(SampleType, input.tex);
        textureColor2 = saturate(lightIntensity2 * textureColor2);
        color = lerp(color, textureColor2, alphaMap1.r);

        if (countLayers > 4) {
		    if (depthValue < distanceIntensity) {
                bumpMap = normalTexture3.Sample(SampleType, input.tex);
                bumpMap = (bumpMap * 2.0f) - 1.0f;
                bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
                bumpNormal = normalize(bumpNormal);
                lightIntensity3 = saturate(dot(bumpNormal, lightDir));
			}

            textureColor3 = shaderTexture3.Sample(SampleType, input.tex);
            textureColor3 = saturate(lightIntensity3 * textureColor3);
            color = lerp(color, textureColor3, alphaMap1.g);

            if (countLayers > 6) {
			    if (depthValue < distanceIntensity) {
                    bumpMap = normalTexture4.Sample(SampleType, input.tex);
                    bumpMap = (bumpMap * 2.0f) - 1.0f;
                    bumpNormal = input.normal + bumpMap.x * input.tangent + bumpMap.y * input.binormal;
                    bumpNormal = normalize(bumpNormal);
                    lightIntensity4 = saturate(dot(bumpNormal, lightDir));
				}

                textureColor4 = shaderTexture4.Sample(SampleType, input.tex);
                textureColor4 = saturate(lightIntensity4 * textureColor4);
                color = lerp(color, textureColor4, alphaMap1.b);
            }
        }
    }
    
    return color;
}